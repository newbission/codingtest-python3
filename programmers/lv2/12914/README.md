# [멀리 뛰기](https://school.programmers.co.kr/learn/courses/30/lessons/12914)

## 개요
> ### 문제
> 효진이는 멀리 뛰기를 연습하고 있습니다. 효진이는 한번에 1칸, 또는 2칸을 뛸 수 있습니다. 칸이 총 4개 있을 때, 효진이는  
> `(1칸, 1칸, 1칸, 1칸)`  
> `(1칸, 2칸, 1칸)`  
> `(1칸, 1칸, 2칸)`  
> `(2칸, 1칸, 1칸)`  
> `(2칸, 2칸)`  
> 의 5가지 방법으로 맨 끝 칸에 도달할 수 있습니다. 멀리뛰기에 사용될 칸의 수 `n`이 주어질 때, 효진이가 끝에 도달하는 방법이 몇 가지인지 알아내, 여기에 `1234567`를 나눈 나머지를 리턴하는 함수, `solution`을 완성하세요. 예를 들어 4가 입력된다면, 5를 `return`하면 됩니다.
>
> 요약: 한 번에 1칸 또는 2칸만 뛸 수 있을 때 `n`번 째 칸에 도달할 수 있는 모든 경우의 수

> # 주요 제한사항
> $1 \le n \le 2,000$

<h1 align="center"><br><br><br>❗️❗️ 스포주의 ❗️❗️<br><br><br></h1>

## 풀이
### 접근
- ~~1번 칸부터 `n`번 칸까지 재귀함수로 1씩 더하면 되겠다~~ $\to$ 시간초과
- 파보나치 수열($f(n) = f(n-1) + f(n-2)$) 적용 $\to$ DP

### 코드
```python
def solution(n):
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1
    for i in range(2, n + 1):
        dp[i] = (dp[i - 1] + dp[i - 2]) % 1234567
    return dp[n]
```

### 설명
1. 초기 세팅을 위해 0, 1번 칸에 1 삽입
2. 2번 칸부터 `n`번 칸 까지 파보나치 수열 적용
3. 모듈러 연산을 통해 저장되는 값을 항상 최소화

### 다른 사람 풀이 보고 느낀점
```python
def solution(n):
    a, b = 0, 1
    for i in range(n):
        a, b = b, (a + b) % 1234567
    return b
```
> 굳이 이전 값만 알면 되는 것에는 리스트를 사용하는 것 보다 변수 두개만 사용하는게 좀 더 효율적이라는 걸 느낌
