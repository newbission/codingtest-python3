# [괄호 회전하기](https://school.programmers.co.kr/learn/courses/30/lessons/76502)

## 개요
> ### 문제
> 다음 규칙을 지키는 문자열을 올바른 괄호 문자열이라고 정의합니다.
>
> - `()`, `[]`, `{}` 는 모두 올바른 괄호 문자열입니다.
> - 만약 `A`가 올바른 괄호 문자열이라면, `(A)`, `[A]`, `{A}` 도 올바른 괄호 문자열입니다. 예를 들어, `[]` 가 올바른 괄호 문자열이므로, `([])` 도 올바른 괄호 문자열입니다.
> - 만약 `A`, `B`가 올바른 괄호 문자열이라면, `AB` 도 올바른 괄호 문자열입니다. 예를 들어, `{}` 와 `([])` 가 올바른 괄호 문자열이므로, `{}([])` 도 올바른 괄호 문자열입니다.
> 
> 대괄호, 중괄호, 그리고 소괄호로 이루어진 문자열 `s`가 매개변수로 주어집니다. 이 `s`를 왼쪽으로 `x (0 ≤ x < (s의 길이))` 칸만큼 회전시켰을 때 `s`가 올바른 괄호 문자열이 되게 하는 `x`의 개수를 `return` 하도록 `solution` 함수를 완성해주세요.
>
> **요약**: 괄호를 한칸씩 밀면서 올바른 괄호인지 체크

> ### 주요 제한사항
> .

<h1 align="center"><br><br><br>❗️❗️ 스포주의 ❗️❗️<br><br><br></h1>

## 풀이
### 접근
- `()`, `{}`, `[]`를 각각 `a`, `b`, `c`에 `+1`, `-1`로 계산
- 만약 음수가 나오면 순서가 안맞으므로 올바르지 않은 케이스
- ❌ $\to$ **`[(])`**와 같은 순서로 있어도 정답 처리
- 딕셔너리로 각 괄호에 점수를 부여 후 열리는건 리스트에 저장 닫히는 괄호가 나왔을 때 마지막 열리는 괄호가 같은 쌍인지 체크

### 코드
```python
def solution(s):
    answer = len(s)
    brackets = {
        "(": 1,
        "{": 2,
        "[": 3,
        "]": -3,
        "}": -2,
        ")": -1,
    }
    a = 0
    for o in s:
        a += brackets[o]
    if a != 0:
        return 0

    for i in range(len(s)):
        l = []
        for o in s:
            if brackets[o] > 0:
                l.append(o)
            elif len(l) == 0 or brackets[o] + brackets[l.pop()] != 0:
                answer -= 1
                break
        s = [*s[1:], s[0]]

    return answer
```

### 설명
1. `answer`를 최대 개수로 설정 $\to$ `len(s)`인 이유는 `s`의 길이만큼 반복하기 때문
2. 최초 한 번 모든 괄호의 쌍이 맞는지 최초 $\to$ `a`가 `0`이 아니라면 쌍이 안맞는 것
   1. 지금와서 생각해 보니 `(((]` 하면 `0`이 나와서 살짝 부족한 방법
   2. 이 때는 `a`, `b`, `c`로 해서 각각 세는 것이 더 좋았을 거 같음
3. 이제 `s`를 바꿔가면서 괄호 맞추기
4. 열리는 괄호는 `l`에 저장 닫히는 괄호가 나오면 `l` 마지막 부분을 `pop`해서 가져온 뒤 비교
5. 더했을 때 `0`이 아니라면 다른 괄호이므로 `answer -= 1` 해주고 반복문 종료
6. `s = [*s[1:], s[0]]`: `s` 한 칸씩 밀기

### 다른 사람 풀이 보고 느낀점
```python
 while True:
    if "()" in s: s=s.replace("()","")
    elif "{}" in s: s=s.replace("{}","")
    elif "[]" in s: s=s.replace("[]","")
    else: return False if s else True       
```
> `replace`를 쓰는 방법도 있는데 이런 방법이 속도가 더 느릴 거 같긴 한데 구현하기에는 더 빨라서 좋긴 하겠다는 생각도 들었음  
